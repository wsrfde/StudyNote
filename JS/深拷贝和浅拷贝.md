### 深拷贝和浅拷贝

> 在了解深拷贝和浅拷贝之前，我们先来了解一下什么是原始值和引用值，及堆和栈

原始值：  存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置

原始类型 ：`Undefined、Null、Boolean、Number 和 String `



引用值 ：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处

引用类型：对象

<img src=".\img\深拷贝浅拷贝的堆栈.png" alt="image-20210528081924695" style="zoom:50%;" />

#### 按值传递和引用传递的区别

* 按值传递：基本类型是不可变的

  ```js
  //按值传递(call by value)
   var num1=100;
   function test(n){
     num2=n
  	 num2=200; 
  } 
  test(num1); 
  console.log(num1); //=> 100
  ```

  可以看到栈中的数据并没有改变，因为栈中的数据在传递的时候会复制一份，并不会随着原始值的改变而改变

  <img src=".\img\深拷贝和浅拷贝的按值传递.png" alt="image-20210528083701121" style="zoom:50%;" />

* 引用传递：对象的值是引用的，可变的

  ```js
  //按引用传递(call by reference) 
  var obj1 = {x : 1};
  function test(n){ 
    obj2=n
  	obj2.x=2; 
  } 
  test(obj1);
  console.log(obj1.x); //=> 2
  ```

  因为obj1和obj2指向的是同一个内存，所以当修改时obj2的参数时，等同于修改obj1的参数

<img src=".\img\深拷贝浅拷贝的引用传递.png" alt="image-20210528085140756" style="zoom:50%;" />

但问题来了，如果我们拷贝了一份对象，并不想在obj2改变的时候obj1跟着改变该怎么办？

### 什么是深拷贝和浅拷贝

概念：

**浅拷贝：**拷贝的值改变时只拷贝一层，这一层得数据开辟了新得内存空间，数据改变无影响。如果数据中有对象类型，则还是指向内存引用跟随边改

**深拷贝**：拷贝的值可以无限层拷贝，不限制当前层的拷贝，对象中的值与原始值不发生任何影响



#### 浅拷贝的使用

##### 浅拷贝方式一

> 使用原生API进行浅拷贝

```js
let oldObj = {name:'vicer',age:18,childInfo:{name:'tace'}}

//赋值对象是一个obj
newObj =Object.assign({}, oldObj) //这样就不会共用同一个对象

//数组我们也有一个巧妙的防范
newArray = oldArray.slice(); //slice会clone返回一个新数组
```

注意浅拷贝只是拷贝第一层

```js
newObj.name = '小明'
newObj.childInfo.name = '小黑'
console.log(oldObj.name)  //=> vicer	可以看到浅拷贝成功，没有跟随newObj变化
console.log(oldObj.childInfo.name)	//=> '小黑'		因为只拷贝一层，所以第二层的数据还是指向内存地址，跟随改变
```

##### 浅拷贝方式二

> 使用对象/数组的解构赋值，进行浅拷贝

```js
// 浅拷贝对象
const obj = { a: 1 }
const objClone = { ...obj }

// 浅拷贝数组
const arr = [1, 2, 3]
const arrClone = [...arr]
```

##### 浅拷贝方式三

> 使用lodash

```js
const obj = { a: 1 }
const objClone = _.clone(obj)
```



#### 深拷贝的使用

##### 深拷贝方式一

> 使用JSON的API

```js
let oldObj = {name:'vicer',age:18,childInfo:{name:'tace'}}

let newObj = JSON.parse(JSON.stringify(oldObj))
```

改变深拷贝数据，查看是否拷贝成功

```js
newObj.childInfo.name = '小红'
console.log(oldObj.childInfo.name)	//=> tace   深拷贝成功！
```

##### 深拷贝方式二

> 使用lodash

```js
let oldObj = {name:'vicer',age:18,childInfo:{name:'tace'}}

let newObj = _cloneDeep(oldObj)
```



